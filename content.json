[{"title":"js时间转换","date":"2020-05-21T14:42:54.000Z","path":"2020/05/21/js时间转换/","text":"js时间转换参考：https://www.cnblogs.com/tosee/p/5538007.html UTC：UTC指的是Coordinated Universal Time－ 世界协调时间（又称世界标准时间、世界统一时间），是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。 GMT：十七世纪，格林威治皇家天文台为了海上霸权的扩张计画而进行天体观测。1675年旧皇家观测所(Old Royal Observatory) 正式成立，到了1884年决定以通过格林威治的子午线作为划分地球东西两半球的经度零度。观测所门口墙上有一个标志24小时的时钟，显示当下的时间，对全球而言，这里所设定的时间是世界时间参考点，全球都以格林威治的时间作为标准来设定时间，这就是我们耳熟能详的「格林威治标准时间(Greenwich Mean Time，简称G.M.T.)的由来，标示在手表上，则代表此表具有两地时间功能，也就是同时可以显示原居地和另一个国度的时间。 UTC与GMT一般视为无差，UTC是以原子时计时,更加精准,适应现代社会的精确计时。不过一般使用不需要精确到秒时,视为等同。GMT是前世界标准时，UTC是现世界标准时。 整个地球分为二十四时区北京时区是东八区，领先UTC八个小时&#x3D;&#x3D;UTC + 时区差 ＝ 本地时间&#x3D;&#x3D; ISO： 国际标准化组织的国际标准ISO 8601是日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》形如：”2020-05-21T13:51:09.962Z” ISO时间转为时间戳：12345//获取ISO时间 new Date().toISOString()function isoToTimestamp(isodate) &#123; let format = Date.parse(isodate.replace(/-/g, &#x27;/&#x27;).replace(/T/g, &#x27; &#x27;).replace(/Z/, &quot;&quot;)) return format;&#125; UTC时间格式化， 时间戳格式化1234567891011121314151617let UTCDate = new Date(时间戳);//UTC时间格式化 YYYY-MM-DD HH:MM:SS params:date 为Date对象。function formatTime(date) &#123; !date &amp;&amp; (date = new Date()); let year = date.getFullYear(); let month = date.getMonth() + 1; let day = date.getDate(); let hour = date.getHours(); let minute = date.getMinutes(); let second = date.getSeconds(); return `$&#123;year&#125;-$&#123;padLeft(month)&#125;-$&#123;padLeft(day)&#125; $&#123;padLeft(hour)&#125;:$&#123;padLeft(minute)&#125;:$&#123;padLeft(second)&#125;`;&#125;function padLeft(str) &#123; return (&quot;&quot; + str).padStart(2,&quot;0&quot;);&#125;","tags":[]},{"title":"javascript设计模式","date":"2019-11-21T15:00:05.000Z","path":"2019/11/21/javascript设计模式/","text":"1. 设计模式设计模式（Design pattern）是一套被反复使用、思想成熟、经过分类和无数实战设计经验的总结的。使用设计模式是为了让系统可重用、可扩展、可解耦、更容易被人理解且能保证代码可靠性。设计模式是代码开发真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。只有夯实地基搭好结构，才能盖好坚壮的大楼。 2. 设计模式分为三种类型，共23种： 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 3. 设计原则设计模式存在的根本原因是为了代码可复用，增加可维护性。 【单一职责原则】 一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立。 【开闭原则】 对扩展开放，对修改关闭。 在程序需要进行扩展的时候，不能去修改原有的代码，这也是为了使程序的扩展性更好、易于升级和维护。 【里式转换原则】 子类继承父类后，对子类进行扩展扩展时尽量不要重写父类的方法，也不要影响父类的方法。 【依赖倒转原则】 面向接口编程，依赖于抽象而不依赖于具体使用方只关注接口而不关注具体类的实现。 【接口隔离原则】 使用多个隔离的接口，比使用单个接口要好，一个接口应该是一种角色。 【迪米特原则】 一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 【合成复用原则】 新的对象应使用一些已有的对象，使之成为新对象的一部分。","tags":[]},{"title":"防抖与节流","date":"2019-09-26T14:55:53.000Z","path":"2019/09/26/防抖与节流/","text":"防抖与节流节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。 防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！ 使用场景：节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。 防抖与节流主要是用于用户交互处理过程中的性能优化，都是为了避免在短时间内重复触发导致的资源浪费问题。例如在进行窗口的resize、scroll，输入框内容校验等操作。 防抖（debounce）通过设置定时器，在延迟的时间内每次触发都会重置定时器，直到在某个延迟时间点内不再触发事件才会执行。 123456789function debounce(fn, delay = 1000) &#123; let timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, delay) &#125;&#125; 节流（throttle）高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。 函数节流就是预定一个函数只有在大于等于执行周期是才执行，周期内调用不执行（水达到一定程度才滴落） 1234567891011//节流throttle代码 （时间戳）function throttle(fn, delay = 1000) &#123; let startTime = Date.now(); return function() &#123; let nowTime = Date.now(); if (nowTime - startTime &gt;= delay) &#123; fn.apply(this, arguments); startTime = Date.now(); &#125; &#125;&#125; 当高频事件触发时，第一次会立即执行，而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了。 123456789101112//节流throttle代码 （定时器）function throttle(fn, delay) &#123; let timer = null; return function() &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay) &#125; &#125;&#125; 当触发事件的时候，设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数 12345678910111213141516// 节流throttle代码（时间戳+定时器）：function throttle(fn, delay) &#123; let timer = null; let startTime = Date.now(); return function() &#123; let nowTime = Date.now(); var remaining = delay - (nowTime - startTime); clearTimeout(timer); if (remaining &lt;= 0) &#123; fn.apply(this, arguments); startTime = Date.now(); &#125; else &#123; timer = setTimeout(fn, remaining); &#125; &#125;&#125; 在节流函数内部使用开始时间startTime、当前时间nowTime与delay来计算剩余时间remaining，当remaining&lt;&#x3D;0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。","tags":[]},{"title":"Vue TypeScript","date":"2019-06-30T15:28:57.000Z","path":"2019/06/30/Vue ts/","text":"1. TypeScript简介TypeScript 是 JavaScript的超集，支持所有的JavaScript语法。并在此之上对 JavaScript添加了一些扩展，如 class &#x2F; interface &#x2F; module 等。这样会大大提升代码的可阅读性 1234//安装npm install -g typescript//编译tsc helloworld.ts 2. vue-class-componentvue-class-component 对 Vue 组件进行了一层封装，让 Vue组件语法在结合了 TypeScript 语法之后更加扁平化： 12345678910111213141516171819202122&lt;script lang=&quot;ts&quot;&gt; import Vue from &#x27;vue&#x27; import Component from &#x27;vue-class-component&#x27; @Component export default class App extends Vue &#123; // 初始化数据 msg = 123 // 声明周期钩子 mounted () &#123; this.greet() &#125; // 计算属性 get computedMsg () &#123; return &#x27;computed &#x27; + this.msg // 方法 greet () &#123; alert(&#x27;greeting: &#x27; + this.msg) &#125; &#125;&lt;/script&gt; 2. vue-property-decoratorvue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器： @Emit @Inject @Model @Prop @Provide @Watch @Component (从 vue-class-component 继承) 123456789101112131415161718192021222324252627282930313233343536373839import &#123; Component, Emit, Inject, Model, Prop, Provide, Vue, Watch &#125; from &#x27;vue-property-decorator&#x27;@Componentexport default class HelloWorld extends Vue &#123; @Prop() msg!: string; //data name = &#x27;zhengyan&#x27;; newName = &#x27;&#x27;; //生命周期 created(): void &#123;console.log(&#x27;created&#x27;)&#125;; mounted(): void &#123;console.log(&#x27;mounted&#x27;)&#125;; updated(): void &#123;console.log(&#x27;updated&#x27;)&#125;; destroyed(): void &#123;console.log(&#x27;destroyed&#x27;)&#125;; //计算属性: computed get reversedMsg(): string[] &#123; return [&#x27;zyan&#x27;] &#125;; //侦听属性 @Watch(&quot;name&quot;, &#123; immediate: true, deep: true &#125;) onNameChange(newValue) &#123; this.newName = newValue; &#125; //method changeMessage(): void &#123; console.log(&#x27;changeMessage&#x27;) &#125;; getName(): string &#123; console.log(this.msg); console.log(this.reversedMsg); return &#x27;zyan&#x27;; &#125;;&#125;","tags":[]},{"title":"js数组去重","date":"2019-06-21T15:35:12.000Z","path":"2019/06/21/js数组去重/","text":"数组去重1. ES6 Set结构去重(简单粗暴)1let dedupArr = [...new Set(arr)]; 2. 遍历数组法 12345678910function dedup(arr) &#123; let tempArr = []; //遍历当前数组 for(let i = 0; i &lt; arr.length; i++) &#123; //判断arr[i]是否在临时数组中，不在则将arr[i]的值复制到tempArr里 if(tempArr.indexOf(arr[i]) === -1) tempArr.push(arr[i]); //if(!tempArr.includes(arr[i])) tempArr.push(arr[i]); &#125; return tempArr;&#125; 3. 排序法12345678910function dedup(arr) &#123; let tempArr = []; arr.sort(); tempArr.push(arr[0]); //数组排序后重复的元素一定相邻，判断当前数数组第i个元素与临时数组的最后一个元素是否相等，不相等时复制元素 for(let i = 0; i &lt; arr.length; i++) &#123; if(arr[i] != tempArr[tempArr.length - 1) tempArr.push(arr[i]); &#125; return tempArr;&#125; 4. 对象法123456789101112function dedup(arr) &#123; let tempArr = []; let obj = &#123;&#125;; //将数组的元素值当作对象的属性，遍历数组对比对象属性，不存在这个属性就将当前数组元素复制到临时数组，并添加该属性到对象且将属性值赋为1 for(let i = 0; i &lt; arr.length; i++)&#123; if(!obj[arr[i]]) &#123; tempArr.push(arr[i]); obj[arr[i]] = 1; &#125; &#125; return tempArr;&#125;","tags":[]},{"title":"前端数据存储","date":"2019-04-22T15:00:04.000Z","path":"2019/04/22/前端数据存储/","text":"在客户端存储用户信息的技术，一般存储登录信息、偏好设置或其他数据。 cookie sessionStorage localStorage 一、localStroage 什么是localStroage 主要用来作为本地存储来使用，解决cookie存储空间不足的问题（4k），localStorage一般浏览器支持的是5M，不同浏览器有所不同。localStorage受同源策略约束，要访问该对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。 优势 localStorage拓展了cookie的4K限制 localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的。 局限 浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性 目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换 localStorage在浏览器的隐私模式下面是不可读取的 localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 localStorage不能被爬虫抓取到 使用 名称 作用 setItem 存储数据 getItem 读取数据 removeItem 删除某个具体变量 clear 清空localStorage上存储的数据 存储（修改时同理） 123456//方法一：localStorage.setItem(&quot;isLogin&quot;, true);//方法二：localStorage[&quot;isLogin&quot;] = true;//方法三：localStorage.isLogin = true; 读取 123456//方法一：localStorage.getItem(&quot;isLogin&quot;);//方法二：localStorage[&quot;isLogin&quot;];//方法三：localStorage.isLogin; 删除 1234//删除所有内容：localStorage.clear();//删除某个：localStorage.removeItem(&quot;isLogin&quot;); 注意事项将一个JSON对象存入localStorage中，需要将其转化为JSON字符串，使用时将在转为对象形式。 123456789101112131415//错误let obj = &#123;a: 1, b: 2&#125;;localStorage.setItem(&quot;obj&quot;, obj)console.log(localStorage.getItem(&quot;obj&quot;)) //[object Object]//正确let obj = &#123;a: 1, b: 2&#125;;localStorage.setItem(&quot;obj&quot;, JSON.stringify(obj));let getObj = localStorage.getItem(&quot;obj&quot;);console.log(getObj) //&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot;typeof(getObj) //string//使用时转换为对象JSON.parse(getObj) //&#123;a: 1, b: 2&#125;typeof(JSON.parse(getObj)) //object","tags":[]},{"title":"vue 学习1 -- 环境的搭建及安装（CLI3）","date":"2019-04-14T16:26:49.000Z","path":"2019/04/15/vue-学习1-环境的搭建及安装（CLI3）/","text":"1. 安装node环境和npm Node 版本要求Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。 检查node版本及npm版本 node -vnpm -v 2. 安装cli3 之前项目使用CLI2，跟随技术跟新的脚步，这次学习使用CLI3, Vue CLI 的包名称由 vue-cli 改成了 @vue&#x2F;cli。若安装了旧版本的，还是先 npm uninstall vue-cli -g 卸载它。 npm install -g @vue&#x2F;cli &#x2F;&#x2F;全局安装 安装完后使用 vue -V &#x2F; vue –version 检查是否安装正确。 3. 使用cli3创建一个项目 创建项目 1$ vue create vue-practice 选择如下，将vue核心插件安装 123456789? Please pick a preset: Manually select features? Check the features needed for your project: (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex&gt;(*) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing 使用history路由模式 1? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) 选择css处理器，一般选择第一个就可以了 12345? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys)&gt; Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) Less Stylus 代码风格，选择Prettier. 什么是Prettier？一个有态度的代码格式化工具，支持多种语言，继承绝大多数编辑器，选项少，只需要保存文件，代码就会被整理格式，代码复查的时候不需要再争论风格，节约你的时间和精力。 12345? Pick a linter / formatter config: ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config&gt; ESLint + Prettier 什么时候进行校验，这里选择每次保存的时候进行校验。 123? Pick additional lint features:&gt;(*) Lint on save ( ) Lint and fix on commit 选择lint的配置文件如何存放，这里我选了分别存到具体的config文件，而不是package.json，便于管理。 123? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)&gt; In dedicated config files In package.json 把刚刚选择的配置文件保存起or不保存，这里选择不保存。 1? Save this as a preset for future projects? (y/N) n 等待创建，初始化项目。 123456Vue CLI v3.5.1✨ Creating project in D:\\new document\\00study\\vue学习\\vue-practice.🗃 Initializing git repository...⚙ Installing CLI plugins. This might take a while...[ .................] - fetchMetadata: sill pacote range manifest for @babel/plugin-proposal-unicode-propert 启动项目 $ npm run serve 12345678910$ npm run serve//成功启动：DONE Compiled successfully in 7430ms App running at: - Local: http://localhost:8080/ - Network: http://192.168.232.1:8080/ Note that the development build is not optimized. To create a production build, run npm run build. 或者使用启动GUI界面，方便启动观察项目情况。 $ vue ui 123$ vue ui🚀 Starting GUI...🌠 Ready on http://localhost:8000","tags":[]},{"title":"vue学习前言","date":"2019-04-03T14:47:54.000Z","path":"2019/04/03/vue学习前言/","text":"创建github博客至今，从没写过一篇正式的博客文章。作为一名小小的软件开发人员，这实在是说不过去呀。不为写下精辟言论，不为写下高深代码，只为记录自己在web开发的路上，给自己留下回忆的脚步。 记得有次面试，面试官问我，你擅长什么技术？我答：“VUE”, “那你给我说说VUE是什么？，我不懂前端，你不用说什么专业词语，简单明了的说一下就好。”，当时我答的很是稀烂…, 好吧贴出官网给的解释。 Vue: 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。 总结一下： VUE是一种前端页面的构建框架，是以数据驱动视图的页面工具，可以快速开发页面的一种工具。 后面文章记录关于vue的学习笔记。加油！！！","tags":[]},{"title":"继承","date":"2018-06-23T11:52:33.000Z","path":"2018/06/23/继承/","text":"一、继承的发展史：1、传统形式： 原型链 过多地继承了没用的属性 2、借用构造函数 不能继承借用构造函数的原型 每次构造函数都要多走一个函数 3、共享原型 不能随便改动自己的原型 4、圣杯模式 对象希望改变自己的原型的一些属性同时也不影响其他属性 原型：https://blog.csdn.net/qq_41135015/article/details/78739488 二、在原型上所添加的任何属性都是给祖先所添加的，当祖先的子类需要使用这些属性的时候，由于这些属性已经通过原型来添加到祖先上了，所以子类都可以使用这些属性。·不能通过修改后代修改祖先的内容; ·可以利用原型的概念与特性来提取共有属性; 12345678910111213141516171819202122232425262728293031//当前案例是一个圣杯模式案例Father.prototype.lastname = &#x27;C&#x27;;Father.prototype.fortune = 1000000;function Father () &#123; this.age = 48;&#125;function Son () &#123; this.age = 18; this.waste = function () &#123; return this.fortune - 50000; &#125;&#125;var inherit = (function () &#123; //创建圣杯inherit函数 return function (targetSon, originFather) &#123; //让目标儿子继承源头父亲 function buffer () &#123;&#125; //buffer函数是一个闭包，仅用做一个缓冲而不做他用 buffer.prototype = originFather.prototype; //targetSon.prototype = buffer.prototype; /* 不能这么写，因为这样写就相当于对象targetSon、fatherOrigin和buffer共享原型了 */ targetSon.prototype = new buffer(); /* 使对象targetSon试图修改自身属性时仅仅是以buffer函数作为对象进行修改，而不会影响到其他对象 */ targetSon.prototype.constructor = targetSon; //令目标儿子记得自己本质是谁 targetSon.prototype.gene = originFather; //令目标儿子记得自己的生父是谁 &#125; &#125;)()inherit(Son, Father); //调用圣杯inherit函数Son.prototype.lastname = &#x27;X&#x27;;var son = new Son();var father = new Father();console.log(son.lastname); //控制台显示x，败家儿子成功认贼作父console.log(father.lastname); /* 控制台显示c，父亲自己的姓并没有因为败家儿子 通过改姓来认贼作父的惨痛事实而改变 */console.log(son.constructor); //控制台显示儿子自己的构造函数(本质)console.log(son.gene); //控制台显示儿子自己的生父 使用立即函数的原因：函数执行前会进行预编译，预编译过程都会产生AO，如当前案例所示，案例中的立即执行函数(注：以下简称立函)执行前预编译的AO中有buffer函数，由于当立函执行完毕时会返回一个匿名函数(注：以下简称匿函)，这个匿函调用了buffer函数，最终匿函也被赋予到了inherit函数中，导致立函执行前预编译产生的AO在立函执行完毕后并不会销毁，于是buffer函数成为了一个闭包并被一同赋予到了inherit函数中去了，这样当在外部使用inherit函数时，将会一直都在使用一个buffer函数，而不用每次使用时都再新建一个buffer函数。 圣杯模式可以把一个家族中的各个对象的干扰给截断，以使每个对象在对父类有继承的情况下相互独立，以免各个对象在试图修改自身(特别是自身原型)的属性时影响到其他对象。","tags":[]}]